"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./utils/messageUtils.js":
/*!*******************************!*\
  !*** ./utils/messageUtils.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   containsImageUrl: () => (/* binding */ containsImageUrl),\n/* harmony export */   extractImageUrl: () => (/* binding */ extractImageUrl),\n/* harmony export */   extractMessageFromResponse: () => (/* binding */ extractMessageFromResponse),\n/* harmony export */   formatMessage: () => (/* binding */ formatMessage),\n/* harmony export */   hasValidMessage: () => (/* binding */ hasValidMessage),\n/* harmony export */   parseOptions: () => (/* binding */ parseOptions)\n/* harmony export */ });\n// utils/messageUtils.js\n/**\n * Utility functions for message handling and formatting\n */ /**\n * Formats message data to ensure it's in a consistent string format\n * @param {any} messageData - The message data to format (could be string, object, null, etc.)\n * @returns {string} - The formatted message string\n */ const formatMessage = (messageData)=>{\n    // Handle undefined/null case\n    if (messageData === undefined || messageData === null) {\n        return '';\n    }\n    // Handle string case\n    if (typeof messageData === 'string') {\n        return messageData;\n    }\n    // Handle object case\n    if (typeof messageData === 'object') {\n        // Try to extract text from common object structures\n        if (messageData.text) {\n            return messageData.text;\n        } else if (messageData.content) {\n            return messageData.content;\n        } else if (messageData.message) {\n            return messageData.message;\n        } else {\n            try {\n                return JSON.stringify(messageData, null, 2);\n            } catch (error) {\n                console.error('Error stringifying message object:', error);\n                return '[Complex object]';\n            }\n        }\n    }\n    // Handle other types (number, boolean, etc.)\n    return String(messageData);\n};\n/**\n * Parse multiple choice options from a message text\n * @param {string} messageText - The message text to parse\n * @returns {string[]} - Array of option strings\n */ const parseOptions = (messageText)=>{\n    const formattedText = formatMessage(messageText);\n    const options = [];\n    if (!formattedText) {\n        return options;\n    }\n    const lines = formattedText.split('\\n');\n    // Extract options (A., B., C., D. format)\n    for (const line of lines){\n        if (line.match(/^[A-D]\\.\\s/)) {\n            options.push(line.trim());\n        }\n    }\n    return options;\n};\n/**\n * Checks if a response contains a valid message\n * @param {object} response - The API response object\n * @returns {boolean} - Whether the response has a valid message\n */ const hasValidMessage = (response)=>{\n    return response && (response.message !== undefined || typeof response === 'string' || typeof response === 'object' && !response.competency_status);\n};\n/**\n * Extracts the message content from a response\n * @param {object} response - The API response object\n * @returns {string} - The extracted message content\n */ const extractMessageFromResponse = (response)=>{\n    if (!response) {\n        return '';\n    }\n    if (response.message !== undefined) {\n        return response.message;\n    } else if (typeof response === 'string') {\n        return response;\n    } else if (typeof response === 'object' && !response.competency_status) {\n        return response;\n    }\n    return '';\n};\n/**\n * Checks if a text contains an image URL\n * @param {string} text - Text to check for image URLs\n * @returns {boolean} - Whether the text contains an image URL\n */ const containsImageUrl = (text)=>{\n    if (!text || typeof text !== 'string') return false;\n    // Check for common image extensions\n    const imageExtensionRegex = /https?:\\/\\/\\S+\\.(jpg|jpeg|png|gif|bmp|webp|svg)(\\?.*)?(\\s|$)/i;\n    // Check for Google Drive image links specifically - note the updated pattern\n    const driveImageRegex = /https?:\\/\\/drive\\.(?:google\\.)?usercontent\\.google\\.com\\/(?:download|view)\\S*/i;\n    // Check for content IDs in Google Drive links\n    const driveContentRegex = /id=[\\w-]+/i;\n    return imageExtensionRegex.test(text) || driveImageRegex.test(text) && driveContentRegex.test(text);\n};\n/**\n * Extracts image URL from text\n * @param {string} text - Text containing an image URL\n * @returns {string|null} - The extracted image URL or null if not found\n */ const extractImageUrl = (text)=>{\n    if (!text || typeof text !== 'string') return null;\n    // Try to match standard image URLs first\n    const imageMatch = text.match(/https?:\\/\\/\\S+\\.(jpg|jpeg|png|gif|bmp|webp|svg)(\\?[^\"'\\s]*)?/i);\n    if (imageMatch) return imageMatch[0];\n    // Try to match Google Drive image URLs\n    const driveMatch = text.match(/https?:\\/\\/drive\\.(?:google\\.)?usercontent\\.google\\.com\\/\\S+?(?=[\\s\"']|$)/i);\n    if (driveMatch) return driveMatch[0];\n    return null;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL21lc3NhZ2VVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx3QkFBd0I7QUFDeEI7O0NBRUMsR0FFRDs7OztDQUlDLEdBQ00sTUFBTUEsZ0JBQWdCLENBQUNDO0lBQzVCLDZCQUE2QjtJQUM3QixJQUFJQSxnQkFBZ0JDLGFBQWFELGdCQUFnQixNQUFNO1FBQ3JELE9BQU87SUFDVDtJQUVBLHFCQUFxQjtJQUNyQixJQUFJLE9BQU9BLGdCQUFnQixVQUFVO1FBQ25DLE9BQU9BO0lBQ1Q7SUFFQSxxQkFBcUI7SUFDckIsSUFBSSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUNuQyxvREFBb0Q7UUFDcEQsSUFBSUEsWUFBWUUsSUFBSSxFQUFFO1lBQ3BCLE9BQU9GLFlBQVlFLElBQUk7UUFDekIsT0FBTyxJQUFJRixZQUFZRyxPQUFPLEVBQUU7WUFDOUIsT0FBT0gsWUFBWUcsT0FBTztRQUM1QixPQUFPLElBQUlILFlBQVlJLE9BQU8sRUFBRTtZQUM5QixPQUFPSixZQUFZSSxPQUFPO1FBQzVCLE9BQU87WUFDTCxJQUFJO2dCQUNGLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ04sYUFBYSxNQUFNO1lBQzNDLEVBQUUsT0FBT08sT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLHNDQUFzQ0E7Z0JBQ3BELE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFFQSw2Q0FBNkM7SUFDN0MsT0FBT0UsT0FBT1Q7QUFDaEIsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNVSxlQUFlLENBQUNDO0lBQzNCLE1BQU1DLGdCQUFnQmIsY0FBY1k7SUFDcEMsTUFBTUUsVUFBVSxFQUFFO0lBRWxCLElBQUksQ0FBQ0QsZUFBZTtRQUNsQixPQUFPQztJQUNUO0lBRUEsTUFBTUMsUUFBUUYsY0FBY0csS0FBSyxDQUFDO0lBRWxDLDBDQUEwQztJQUMxQyxLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSUUsS0FBS0MsS0FBSyxDQUFDLGVBQWU7WUFDNUJKLFFBQVFLLElBQUksQ0FBQ0YsS0FBS0csSUFBSTtRQUN4QjtJQUNGO0lBRUEsT0FBT047QUFDVCxFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU1PLGtCQUFrQixDQUFDQztJQUM5QixPQUFPQSxZQUNMQSxDQUFBQSxTQUFTakIsT0FBTyxLQUFLSCxhQUNyQixPQUFPb0IsYUFBYSxZQUNuQixPQUFPQSxhQUFhLFlBQVksQ0FBQ0EsU0FBU0MsaUJBQWlCO0FBRWhFLEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTUMsNkJBQTZCLENBQUNGO0lBQ3pDLElBQUksQ0FBQ0EsVUFBVTtRQUNiLE9BQU87SUFDVDtJQUVBLElBQUlBLFNBQVNqQixPQUFPLEtBQUtILFdBQVc7UUFDbEMsT0FBT29CLFNBQVNqQixPQUFPO0lBQ3pCLE9BQU8sSUFBSSxPQUFPaUIsYUFBYSxVQUFVO1FBQ3ZDLE9BQU9BO0lBQ1QsT0FBTyxJQUFJLE9BQU9BLGFBQWEsWUFBWSxDQUFDQSxTQUFTQyxpQkFBaUIsRUFBRTtRQUN0RSxPQUFPRDtJQUNUO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTUcsbUJBQW1CLENBQUN0QjtJQUMvQixJQUFJLENBQUNBLFFBQVEsT0FBT0EsU0FBUyxVQUFVLE9BQU87SUFFOUMsb0NBQW9DO0lBQ3BDLE1BQU11QixzQkFBc0I7SUFFNUIsNkVBQTZFO0lBQzdFLE1BQU1DLGtCQUFrQjtJQUV4Qiw4Q0FBOEM7SUFDOUMsTUFBTUMsb0JBQW9CO0lBRTFCLE9BQVFGLG9CQUFvQkcsSUFBSSxDQUFDMUIsU0FDekJ3QixnQkFBZ0JFLElBQUksQ0FBQzFCLFNBQVN5QixrQkFBa0JDLElBQUksQ0FBQzFCO0FBQy9ELEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTTJCLGtCQUFrQixDQUFDM0I7SUFDOUIsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsVUFBVSxPQUFPO0lBRTlDLHlDQUF5QztJQUN6QyxNQUFNNEIsYUFBYTVCLEtBQUtlLEtBQUssQ0FBQztJQUM5QixJQUFJYSxZQUFZLE9BQU9BLFVBQVUsQ0FBQyxFQUFFO0lBRXBDLHVDQUF1QztJQUN2QyxNQUFNQyxhQUFhN0IsS0FBS2UsS0FBSyxDQUFDO0lBQzlCLElBQUljLFlBQVksT0FBT0EsVUFBVSxDQUFDLEVBQUU7SUFFcEMsT0FBTztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9iYWxxaXNuYWd1d2liL0xpYnJhcnkvQ2xvdWRTdG9yYWdlL09uZURyaXZlLVRlbGVrb21NYWxheXNpYUJlcmhhZC9Eb2N1bWVudHMvQUkvQUktRGF5L3RtLWFpLXdpZGdldC91dGlscy9tZXNzYWdlVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdXRpbHMvbWVzc2FnZVV0aWxzLmpzXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBtZXNzYWdlIGhhbmRsaW5nIGFuZCBmb3JtYXR0aW5nXG4gKi9cblxuLyoqXG4gKiBGb3JtYXRzIG1lc3NhZ2UgZGF0YSB0byBlbnN1cmUgaXQncyBpbiBhIGNvbnNpc3RlbnQgc3RyaW5nIGZvcm1hdFxuICogQHBhcmFtIHthbnl9IG1lc3NhZ2VEYXRhIC0gVGhlIG1lc3NhZ2UgZGF0YSB0byBmb3JtYXQgKGNvdWxkIGJlIHN0cmluZywgb2JqZWN0LCBudWxsLCBldGMuKVxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgZm9ybWF0dGVkIG1lc3NhZ2Ugc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtYXRNZXNzYWdlID0gKG1lc3NhZ2VEYXRhKSA9PiB7XG4gIC8vIEhhbmRsZSB1bmRlZmluZWQvbnVsbCBjYXNlXG4gIGlmIChtZXNzYWdlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IG1lc3NhZ2VEYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIFxuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VcbiAgaWYgKHR5cGVvZiBtZXNzYWdlRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVzc2FnZURhdGE7XG4gIH1cbiAgXG4gIC8vIEhhbmRsZSBvYmplY3QgY2FzZVxuICBpZiAodHlwZW9mIG1lc3NhZ2VEYXRhID09PSAnb2JqZWN0Jykge1xuICAgIC8vIFRyeSB0byBleHRyYWN0IHRleHQgZnJvbSBjb21tb24gb2JqZWN0IHN0cnVjdHVyZXNcbiAgICBpZiAobWVzc2FnZURhdGEudGV4dCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VEYXRhLnRleHQ7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlRGF0YS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gbWVzc2FnZURhdGEuY29udGVudDtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2VEYXRhLm1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlRGF0YS5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWVzc2FnZURhdGEsIG51bGwsIDIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RyaW5naWZ5aW5nIG1lc3NhZ2Ugb2JqZWN0OicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuICdbQ29tcGxleCBvYmplY3RdJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEhhbmRsZSBvdGhlciB0eXBlcyAobnVtYmVyLCBib29sZWFuLCBldGMuKVxuICByZXR1cm4gU3RyaW5nKG1lc3NhZ2VEYXRhKTtcbn07XG5cbi8qKlxuICogUGFyc2UgbXVsdGlwbGUgY2hvaWNlIG9wdGlvbnMgZnJvbSBhIG1lc3NhZ2UgdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUZXh0IC0gVGhlIG1lc3NhZ2UgdGV4dCB0byBwYXJzZVxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFycmF5IG9mIG9wdGlvbiBzdHJpbmdzXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZU9wdGlvbnMgPSAobWVzc2FnZVRleHQpID0+IHtcbiAgY29uc3QgZm9ybWF0dGVkVGV4dCA9IGZvcm1hdE1lc3NhZ2UobWVzc2FnZVRleHQpO1xuICBjb25zdCBvcHRpb25zID0gW107XG4gIFxuICBpZiAoIWZvcm1hdHRlZFRleHQpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBcbiAgY29uc3QgbGluZXMgPSBmb3JtYXR0ZWRUZXh0LnNwbGl0KCdcXG4nKTtcbiAgXG4gIC8vIEV4dHJhY3Qgb3B0aW9ucyAoQS4sIEIuLCBDLiwgRC4gZm9ybWF0KVxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBpZiAobGluZS5tYXRjaCgvXltBLURdXFwuXFxzLykpIHtcbiAgICAgIG9wdGlvbnMucHVzaChsaW5lLnRyaW0oKSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcmVzcG9uc2UgY29udGFpbnMgYSB2YWxpZCBtZXNzYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgLSBUaGUgQVBJIHJlc3BvbnNlIG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciB0aGUgcmVzcG9uc2UgaGFzIGEgdmFsaWQgbWVzc2FnZVxuICovXG5leHBvcnQgY29uc3QgaGFzVmFsaWRNZXNzYWdlID0gKHJlc3BvbnNlKSA9PiB7XG4gIHJldHVybiByZXNwb25zZSAmJiAoXG4gICAgcmVzcG9uc2UubWVzc2FnZSAhPT0gdW5kZWZpbmVkIHx8IFxuICAgIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgfHxcbiAgICAodHlwZW9mIHJlc3BvbnNlID09PSAnb2JqZWN0JyAmJiAhcmVzcG9uc2UuY29tcGV0ZW5jeV9zdGF0dXMpXG4gICk7XG59O1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBtZXNzYWdlIGNvbnRlbnQgZnJvbSBhIHJlc3BvbnNlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgLSBUaGUgQVBJIHJlc3BvbnNlIG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgZXh0cmFjdGVkIG1lc3NhZ2UgY29udGVudFxuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdE1lc3NhZ2VGcm9tUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgaWYgKCFyZXNwb25zZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBcbiAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXNwb25zZS5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlID09PSAnb2JqZWN0JyAmJiAhcmVzcG9uc2UuY29tcGV0ZW5jeV9zdGF0dXMpIHtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdGV4dCBjb250YWlucyBhbiBpbWFnZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBjaGVjayBmb3IgaW1hZ2UgVVJMc1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciB0aGUgdGV4dCBjb250YWlucyBhbiBpbWFnZSBVUkxcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRhaW5zSW1hZ2VVcmwgPSAodGV4dCkgPT4ge1xuICBpZiAoIXRleHQgfHwgdHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gIFxuICAvLyBDaGVjayBmb3IgY29tbW9uIGltYWdlIGV4dGVuc2lvbnNcbiAgY29uc3QgaW1hZ2VFeHRlbnNpb25SZWdleCA9IC9odHRwcz86XFwvXFwvXFxTK1xcLihqcGd8anBlZ3xwbmd8Z2lmfGJtcHx3ZWJwfHN2ZykoXFw/LiopPyhcXHN8JCkvaTtcbiAgXG4gIC8vIENoZWNrIGZvciBHb29nbGUgRHJpdmUgaW1hZ2UgbGlua3Mgc3BlY2lmaWNhbGx5IC0gbm90ZSB0aGUgdXBkYXRlZCBwYXR0ZXJuXG4gIGNvbnN0IGRyaXZlSW1hZ2VSZWdleCA9IC9odHRwcz86XFwvXFwvZHJpdmVcXC4oPzpnb29nbGVcXC4pP3VzZXJjb250ZW50XFwuZ29vZ2xlXFwuY29tXFwvKD86ZG93bmxvYWR8dmlldylcXFMqL2k7XG4gIFxuICAvLyBDaGVjayBmb3IgY29udGVudCBJRHMgaW4gR29vZ2xlIERyaXZlIGxpbmtzXG4gIGNvbnN0IGRyaXZlQ29udGVudFJlZ2V4ID0gL2lkPVtcXHctXSsvaTtcbiAgXG4gIHJldHVybiAoaW1hZ2VFeHRlbnNpb25SZWdleC50ZXN0KHRleHQpIHx8IFxuICAgICAgICAgKGRyaXZlSW1hZ2VSZWdleC50ZXN0KHRleHQpICYmIGRyaXZlQ29udGVudFJlZ2V4LnRlc3QodGV4dCkpKTtcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgaW1hZ2UgVVJMIGZyb20gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IGNvbnRhaW5pbmcgYW4gaW1hZ2UgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IC0gVGhlIGV4dHJhY3RlZCBpbWFnZSBVUkwgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RJbWFnZVVybCA9ICh0ZXh0KSA9PiB7XG4gIGlmICghdGV4dCB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsO1xuICBcbiAgLy8gVHJ5IHRvIG1hdGNoIHN0YW5kYXJkIGltYWdlIFVSTHMgZmlyc3RcbiAgY29uc3QgaW1hZ2VNYXRjaCA9IHRleHQubWF0Y2goL2h0dHBzPzpcXC9cXC9cXFMrXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8Ym1wfHdlYnB8c3ZnKShcXD9bXlwiJ1xcc10qKT8vaSk7XG4gIGlmIChpbWFnZU1hdGNoKSByZXR1cm4gaW1hZ2VNYXRjaFswXTtcbiAgXG4gIC8vIFRyeSB0byBtYXRjaCBHb29nbGUgRHJpdmUgaW1hZ2UgVVJMc1xuICBjb25zdCBkcml2ZU1hdGNoID0gdGV4dC5tYXRjaCgvaHR0cHM/OlxcL1xcL2RyaXZlXFwuKD86Z29vZ2xlXFwuKT91c2VyY29udGVudFxcLmdvb2dsZVxcLmNvbVxcL1xcUys/KD89W1xcc1wiJ118JCkvaSk7XG4gIGlmIChkcml2ZU1hdGNoKSByZXR1cm4gZHJpdmVNYXRjaFswXTtcbiAgXG4gIHJldHVybiBudWxsO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JtYXRNZXNzYWdlIiwibWVzc2FnZURhdGEiLCJ1bmRlZmluZWQiLCJ0ZXh0IiwiY29udGVudCIsIm1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwiU3RyaW5nIiwicGFyc2VPcHRpb25zIiwibWVzc2FnZVRleHQiLCJmb3JtYXR0ZWRUZXh0Iiwib3B0aW9ucyIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwibWF0Y2giLCJwdXNoIiwidHJpbSIsImhhc1ZhbGlkTWVzc2FnZSIsInJlc3BvbnNlIiwiY29tcGV0ZW5jeV9zdGF0dXMiLCJleHRyYWN0TWVzc2FnZUZyb21SZXNwb25zZSIsImNvbnRhaW5zSW1hZ2VVcmwiLCJpbWFnZUV4dGVuc2lvblJlZ2V4IiwiZHJpdmVJbWFnZVJlZ2V4IiwiZHJpdmVDb250ZW50UmVnZXgiLCJ0ZXN0IiwiZXh0cmFjdEltYWdlVXJsIiwiaW1hZ2VNYXRjaCIsImRyaXZlTWF0Y2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/messageUtils.js\n"));

/***/ })

});