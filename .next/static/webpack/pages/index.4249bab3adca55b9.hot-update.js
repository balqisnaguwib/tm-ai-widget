"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./utils/messageUtils.js":
/*!*******************************!*\
  !*** ./utils/messageUtils.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   containsImageUrl: () => (/* binding */ containsImageUrl),\n/* harmony export */   extractImageUrl: () => (/* binding */ extractImageUrl),\n/* harmony export */   extractMessageFromResponse: () => (/* binding */ extractMessageFromResponse),\n/* harmony export */   formatMessage: () => (/* binding */ formatMessage),\n/* harmony export */   hasValidMessage: () => (/* binding */ hasValidMessage),\n/* harmony export */   parseOptions: () => (/* binding */ parseOptions)\n/* harmony export */ });\n// utils/messageUtils.js\n/**\n * Utility functions for message handling and formatting\n */ /**\n * Formats message data to ensure it's in a consistent string format\n * @param {any} messageData - The message data to format (could be string, object, null, etc.)\n * @returns {string} - The formatted message string\n */ const formatMessage = (messageData)=>{\n    // Handle undefined/null case\n    if (messageData === undefined || messageData === null) {\n        return '';\n    }\n    // Handle string case\n    if (typeof messageData === 'string') {\n        return messageData;\n    }\n    // Handle object case\n    if (typeof messageData === 'object') {\n        // Try to extract text from common object structures\n        if (messageData.text) {\n            return messageData.text;\n        } else if (messageData.content) {\n            return messageData.content;\n        } else if (messageData.message) {\n            return messageData.message;\n        } else {\n            try {\n                return JSON.stringify(messageData, null, 2);\n            } catch (error) {\n                console.error('Error stringifying message object:', error);\n                return '[Complex object]';\n            }\n        }\n    }\n    // Handle other types (number, boolean, etc.)\n    return String(messageData);\n};\n/**\n * Parse multiple choice options from a message text\n * @param {string} messageText - The message text to parse\n * @returns {string[]} - Array of option strings\n */ const parseOptions = (messageText)=>{\n    const formattedText = formatMessage(messageText);\n    const options = [];\n    if (!formattedText) {\n        return options;\n    }\n    const lines = formattedText.split('\\n');\n    // Extract options (A., B., C., D. format)\n    for (const line of lines){\n        if (line.match(/^[A-D]\\.\\s/)) {\n            options.push(line.trim());\n        }\n    }\n    return options;\n};\n/**\n * Checks if a response contains a valid message\n * @param {object} response - The API response object\n * @returns {boolean} - Whether the response has a valid message\n */ const hasValidMessage = (response)=>{\n    return response && (response.message !== undefined || typeof response === 'string' || typeof response === 'object' && !response.competency_status);\n};\n/**\n * Extracts the message content from a response\n * @param {object} response - The API response object\n * @returns {string} - The extracted message content\n */ const extractMessageFromResponse = (response)=>{\n    if (!response) {\n        return '';\n    }\n    if (response.message !== undefined) {\n        return response.message;\n    } else if (typeof response === 'string') {\n        return response;\n    } else if (typeof response === 'object' && !response.competency_status) {\n        return response;\n    }\n    return '';\n};\n/**\n * Checks if a text contains an image URL\n * @param {string} text - Text to check for image URLs\n * @returns {boolean} - Whether the text contains an image URL\n */ const containsImageUrl = (text)=>{\n    if (!text || typeof text !== 'string') return false;\n    // Check for common image extensions\n    const imageExtensionRegex = /https?:\\/\\/\\S+\\.(jpg|jpeg|png|gif|bmp|webp|svg)(\\?.*)?(\\s|$)/i;\n    // Check specifically for the TM AI Day floor plan URL format\n    const driveUrlRegex = /https?:\\/\\/drive\\.usercontent\\.google\\.com\\/download\\?id=[\\w-]+(?:&export=view)?(?:&authuser=\\d+)?/i;\n    return imageExtensionRegex.test(text) || driveUrlRegex.test(text);\n};\n/**\n * Extracts image URL from text\n * @param {string} text - Text containing an image URL\n * @returns {string|null} - The extracted image URL or null if not found\n */ const extractImageUrl = (text)=>{\n    if (!text || typeof text !== 'string') return null;\n    // Try to match standard image URLs first\n    const imageMatch = text.match(/https?:\\/\\/\\S+\\.(jpg|jpeg|png|gif|bmp|webp|svg)(\\?[^\"'\\s]*)?/i);\n    if (imageMatch) return imageMatch[0];\n    // Try to match Google Drive download URLs with the specific format from the example\n    const driveMatch = text.match(/https?:\\/\\/drive\\.usercontent\\.google\\.com\\/download\\?id=[\\w-]+(?:&export=view)?(?:&authuser=\\d+)?/i);\n    if (driveMatch) return driveMatch[0];\n    return null;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL21lc3NhZ2VVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx3QkFBd0I7QUFDeEI7O0NBRUMsR0FFRDs7OztDQUlDLEdBQ00sTUFBTUEsZ0JBQWdCLENBQUNDO0lBQzVCLDZCQUE2QjtJQUM3QixJQUFJQSxnQkFBZ0JDLGFBQWFELGdCQUFnQixNQUFNO1FBQ3JELE9BQU87SUFDVDtJQUVBLHFCQUFxQjtJQUNyQixJQUFJLE9BQU9BLGdCQUFnQixVQUFVO1FBQ25DLE9BQU9BO0lBQ1Q7SUFFQSxxQkFBcUI7SUFDckIsSUFBSSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUNuQyxvREFBb0Q7UUFDcEQsSUFBSUEsWUFBWUUsSUFBSSxFQUFFO1lBQ3BCLE9BQU9GLFlBQVlFLElBQUk7UUFDekIsT0FBTyxJQUFJRixZQUFZRyxPQUFPLEVBQUU7WUFDOUIsT0FBT0gsWUFBWUcsT0FBTztRQUM1QixPQUFPLElBQUlILFlBQVlJLE9BQU8sRUFBRTtZQUM5QixPQUFPSixZQUFZSSxPQUFPO1FBQzVCLE9BQU87WUFDTCxJQUFJO2dCQUNGLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ04sYUFBYSxNQUFNO1lBQzNDLEVBQUUsT0FBT08sT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLHNDQUFzQ0E7Z0JBQ3BELE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFFQSw2Q0FBNkM7SUFDN0MsT0FBT0UsT0FBT1Q7QUFDaEIsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNVSxlQUFlLENBQUNDO0lBQzNCLE1BQU1DLGdCQUFnQmIsY0FBY1k7SUFDcEMsTUFBTUUsVUFBVSxFQUFFO0lBRWxCLElBQUksQ0FBQ0QsZUFBZTtRQUNsQixPQUFPQztJQUNUO0lBRUEsTUFBTUMsUUFBUUYsY0FBY0csS0FBSyxDQUFDO0lBRWxDLDBDQUEwQztJQUMxQyxLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSUUsS0FBS0MsS0FBSyxDQUFDLGVBQWU7WUFDNUJKLFFBQVFLLElBQUksQ0FBQ0YsS0FBS0csSUFBSTtRQUN4QjtJQUNGO0lBRUEsT0FBT047QUFDVCxFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU1PLGtCQUFrQixDQUFDQztJQUM5QixPQUFPQSxZQUNMQSxDQUFBQSxTQUFTakIsT0FBTyxLQUFLSCxhQUNyQixPQUFPb0IsYUFBYSxZQUNuQixPQUFPQSxhQUFhLFlBQVksQ0FBQ0EsU0FBU0MsaUJBQWlCO0FBRWhFLEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTUMsNkJBQTZCLENBQUNGO0lBQ3pDLElBQUksQ0FBQ0EsVUFBVTtRQUNiLE9BQU87SUFDVDtJQUVBLElBQUlBLFNBQVNqQixPQUFPLEtBQUtILFdBQVc7UUFDbEMsT0FBT29CLFNBQVNqQixPQUFPO0lBQ3pCLE9BQU8sSUFBSSxPQUFPaUIsYUFBYSxVQUFVO1FBQ3ZDLE9BQU9BO0lBQ1QsT0FBTyxJQUFJLE9BQU9BLGFBQWEsWUFBWSxDQUFDQSxTQUFTQyxpQkFBaUIsRUFBRTtRQUN0RSxPQUFPRDtJQUNUO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTUcsbUJBQW1CLENBQUN0QjtJQUMvQixJQUFJLENBQUNBLFFBQVEsT0FBT0EsU0FBUyxVQUFVLE9BQU87SUFFOUMsb0NBQW9DO0lBQ3BDLE1BQU11QixzQkFBc0I7SUFFNUIsNkRBQTZEO0lBQzdELE1BQU1DLGdCQUFnQjtJQUV0QixPQUFPRCxvQkFBb0JFLElBQUksQ0FBQ3pCLFNBQVN3QixjQUFjQyxJQUFJLENBQUN6QjtBQUM5RCxFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU0wQixrQkFBa0IsQ0FBQzFCO0lBQzlCLElBQUksQ0FBQ0EsUUFBUSxPQUFPQSxTQUFTLFVBQVUsT0FBTztJQUU5Qyx5Q0FBeUM7SUFDekMsTUFBTTJCLGFBQWEzQixLQUFLZSxLQUFLLENBQUM7SUFDOUIsSUFBSVksWUFBWSxPQUFPQSxVQUFVLENBQUMsRUFBRTtJQUVwQyxvRkFBb0Y7SUFDcEYsTUFBTUMsYUFBYTVCLEtBQUtlLEtBQUssQ0FBQztJQUM5QixJQUFJYSxZQUFZLE9BQU9BLFVBQVUsQ0FBQyxFQUFFO0lBRXBDLE9BQU87QUFDVCxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYmFscWlzbmFndXdpYi9MaWJyYXJ5L0Nsb3VkU3RvcmFnZS9PbmVEcml2ZS1UZWxla29tTWFsYXlzaWFCZXJoYWQvRG9jdW1lbnRzL0FJL0FJLURheS90bS1haS13aWRnZXQvdXRpbHMvbWVzc2FnZVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxzL21lc3NhZ2VVdGlscy5qc1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWVzc2FnZSBoYW5kbGluZyBhbmQgZm9ybWF0dGluZ1xuICovXG5cbi8qKlxuICogRm9ybWF0cyBtZXNzYWdlIGRhdGEgdG8gZW5zdXJlIGl0J3MgaW4gYSBjb25zaXN0ZW50IHN0cmluZyBmb3JtYXRcbiAqIEBwYXJhbSB7YW55fSBtZXNzYWdlRGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEgdG8gZm9ybWF0IChjb3VsZCBiZSBzdHJpbmcsIG9iamVjdCwgbnVsbCwgZXRjLilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGZvcm1hdHRlZCBtZXNzYWdlIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZm9ybWF0TWVzc2FnZSA9IChtZXNzYWdlRGF0YSkgPT4ge1xuICAvLyBIYW5kbGUgdW5kZWZpbmVkL251bGwgY2FzZVxuICBpZiAobWVzc2FnZURhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlRGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlXG4gIGlmICh0eXBlb2YgbWVzc2FnZURhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VEYXRhO1xuICB9XG4gIFxuICAvLyBIYW5kbGUgb2JqZWN0IGNhc2VcbiAgaWYgKHR5cGVvZiBtZXNzYWdlRGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBUcnkgdG8gZXh0cmFjdCB0ZXh0IGZyb20gY29tbW9uIG9iamVjdCBzdHJ1Y3R1cmVzXG4gICAgaWYgKG1lc3NhZ2VEYXRhLnRleHQpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlRGF0YS50ZXh0O1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZURhdGEuY29udGVudCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VEYXRhLmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlRGF0YS5tZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZURhdGEubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VEYXRhLCBudWxsLCAyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0cmluZ2lmeWluZyBtZXNzYWdlIG9iamVjdDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiAnW0NvbXBsZXggb2JqZWN0XSc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBIYW5kbGUgb3RoZXIgdHlwZXMgKG51bWJlciwgYm9vbGVhbiwgZXRjLilcbiAgcmV0dXJuIFN0cmluZyhtZXNzYWdlRGF0YSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIG11bHRpcGxlIGNob2ljZSBvcHRpb25zIGZyb20gYSBtZXNzYWdlIHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVGV4dCAtIFRoZSBtZXNzYWdlIHRleHQgdG8gcGFyc2VcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBBcnJheSBvZiBvcHRpb24gc3RyaW5nc1xuICovXG5leHBvcnQgY29uc3QgcGFyc2VPcHRpb25zID0gKG1lc3NhZ2VUZXh0KSA9PiB7XG4gIGNvbnN0IGZvcm1hdHRlZFRleHQgPSBmb3JtYXRNZXNzYWdlKG1lc3NhZ2VUZXh0KTtcbiAgY29uc3Qgb3B0aW9ucyA9IFtdO1xuICBcbiAgaWYgKCFmb3JtYXR0ZWRUZXh0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgXG4gIGNvbnN0IGxpbmVzID0gZm9ybWF0dGVkVGV4dC5zcGxpdCgnXFxuJyk7XG4gIFxuICAvLyBFeHRyYWN0IG9wdGlvbnMgKEEuLCBCLiwgQy4sIEQuIGZvcm1hdClcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgaWYgKGxpbmUubWF0Y2goL15bQS1EXVxcLlxccy8pKSB7XG4gICAgICBvcHRpb25zLnB1c2gobGluZS50cmltKCkpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHJlc3BvbnNlIGNvbnRhaW5zIGEgdmFsaWQgbWVzc2FnZVxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gVGhlIEFQSSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBhIHZhbGlkIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IGhhc1ZhbGlkTWVzc2FnZSA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gcmVzcG9uc2UgJiYgKFxuICAgIHJlc3BvbnNlLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCB8fCBcbiAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnIHx8XG4gICAgKHR5cGVvZiByZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgIXJlc3BvbnNlLmNvbXBldGVuY3lfc3RhdHVzKVxuICApO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgbWVzc2FnZSBjb250ZW50IGZyb20gYSByZXNwb25zZVxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gVGhlIEFQSSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGV4dHJhY3RlZCBtZXNzYWdlIGNvbnRlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RNZXNzYWdlRnJvbVJlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gIGlmICghcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgXG4gIGlmIChyZXNwb25zZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UubWVzc2FnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgIXJlc3BvbnNlLmNvbXBldGVuY3lfc3RhdHVzKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIFxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHRleHQgY29udGFpbnMgYW4gaW1hZ2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgdG8gY2hlY2sgZm9yIGltYWdlIFVSTHNcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgdGhlIHRleHQgY29udGFpbnMgYW4gaW1hZ2UgVVJMXG4gKi9cbmV4cG9ydCBjb25zdCBjb250YWluc0ltYWdlVXJsID0gKHRleHQpID0+IHtcbiAgaWYgKCF0ZXh0IHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBpbWFnZSBleHRlbnNpb25zXG4gIGNvbnN0IGltYWdlRXh0ZW5zaW9uUmVnZXggPSAvaHR0cHM/OlxcL1xcL1xcUytcXC4oanBnfGpwZWd8cG5nfGdpZnxibXB8d2VicHxzdmcpKFxcPy4qKT8oXFxzfCQpL2k7XG4gIFxuICAvLyBDaGVjayBzcGVjaWZpY2FsbHkgZm9yIHRoZSBUTSBBSSBEYXkgZmxvb3IgcGxhbiBVUkwgZm9ybWF0XG4gIGNvbnN0IGRyaXZlVXJsUmVnZXggPSAvaHR0cHM/OlxcL1xcL2RyaXZlXFwudXNlcmNvbnRlbnRcXC5nb29nbGVcXC5jb21cXC9kb3dubG9hZFxcP2lkPVtcXHctXSsoPzomZXhwb3J0PXZpZXcpPyg/OiZhdXRodXNlcj1cXGQrKT8vaTtcbiAgXG4gIHJldHVybiBpbWFnZUV4dGVuc2lvblJlZ2V4LnRlc3QodGV4dCkgfHwgZHJpdmVVcmxSZWdleC50ZXN0KHRleHQpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBpbWFnZSBVUkwgZnJvbSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgY29udGFpbmluZyBhbiBpbWFnZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gLSBUaGUgZXh0cmFjdGVkIGltYWdlIFVSTCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdEltYWdlVXJsID0gKHRleHQpID0+IHtcbiAgaWYgKCF0ZXh0IHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGw7XG4gIFxuICAvLyBUcnkgdG8gbWF0Y2ggc3RhbmRhcmQgaW1hZ2UgVVJMcyBmaXJzdFxuICBjb25zdCBpbWFnZU1hdGNoID0gdGV4dC5tYXRjaCgvaHR0cHM/OlxcL1xcL1xcUytcXC4oanBnfGpwZWd8cG5nfGdpZnxibXB8d2VicHxzdmcpKFxcP1teXCInXFxzXSopPy9pKTtcbiAgaWYgKGltYWdlTWF0Y2gpIHJldHVybiBpbWFnZU1hdGNoWzBdO1xuICBcbiAgLy8gVHJ5IHRvIG1hdGNoIEdvb2dsZSBEcml2ZSBkb3dubG9hZCBVUkxzIHdpdGggdGhlIHNwZWNpZmljIGZvcm1hdCBmcm9tIHRoZSBleGFtcGxlXG4gIGNvbnN0IGRyaXZlTWF0Y2ggPSB0ZXh0Lm1hdGNoKC9odHRwcz86XFwvXFwvZHJpdmVcXC51c2VyY29udGVudFxcLmdvb2dsZVxcLmNvbVxcL2Rvd25sb2FkXFw/aWQ9W1xcdy1dKyg/OiZleHBvcnQ9dmlldyk/KD86JmF1dGh1c2VyPVxcZCspPy9pKTtcbiAgaWYgKGRyaXZlTWF0Y2gpIHJldHVybiBkcml2ZU1hdGNoWzBdO1xuICBcbiAgcmV0dXJuIG51bGw7XG59O1xuIl0sIm5hbWVzIjpbImZvcm1hdE1lc3NhZ2UiLCJtZXNzYWdlRGF0YSIsInVuZGVmaW5lZCIsInRleHQiLCJjb250ZW50IiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJTdHJpbmciLCJwYXJzZU9wdGlvbnMiLCJtZXNzYWdlVGV4dCIsImZvcm1hdHRlZFRleHQiLCJvcHRpb25zIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJtYXRjaCIsInB1c2giLCJ0cmltIiwiaGFzVmFsaWRNZXNzYWdlIiwicmVzcG9uc2UiLCJjb21wZXRlbmN5X3N0YXR1cyIsImV4dHJhY3RNZXNzYWdlRnJvbVJlc3BvbnNlIiwiY29udGFpbnNJbWFnZVVybCIsImltYWdlRXh0ZW5zaW9uUmVnZXgiLCJkcml2ZVVybFJlZ2V4IiwidGVzdCIsImV4dHJhY3RJbWFnZVVybCIsImltYWdlTWF0Y2giLCJkcml2ZU1hdGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/messageUtils.js\n"));

/***/ })

});