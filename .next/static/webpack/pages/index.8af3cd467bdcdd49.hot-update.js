"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./utils/messageUtils.js":
/*!*******************************!*\
  !*** ./utils/messageUtils.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   containsImageUrl: () => (/* binding */ containsImageUrl),\n/* harmony export */   extractImageUrl: () => (/* binding */ extractImageUrl),\n/* harmony export */   extractMessageFromResponse: () => (/* binding */ extractMessageFromResponse),\n/* harmony export */   formatMessage: () => (/* binding */ formatMessage),\n/* harmony export */   hasValidMessage: () => (/* binding */ hasValidMessage),\n/* harmony export */   parseOptions: () => (/* binding */ parseOptions)\n/* harmony export */ });\n// utils/messageUtils.js\n/**\n * Utility functions for message handling and formatting\n */ /**\n * Formats message data to ensure it's in a consistent string format\n * @param {any} messageData - The message data to format (could be string, object, null, etc.)\n * @returns {string} - The formatted message string\n */ const formatMessage = (messageData)=>{\n    // Handle undefined/null case\n    if (messageData === undefined || messageData === null) {\n        return '';\n    }\n    // Handle string case\n    if (typeof messageData === 'string') {\n        return messageData;\n    }\n    // Handle object case\n    if (typeof messageData === 'object') {\n        // Try to extract text from common object structures\n        if (messageData.text) {\n            return messageData.text;\n        } else if (messageData.content) {\n            return messageData.content;\n        } else if (messageData.message) {\n            return messageData.message;\n        } else {\n            try {\n                return JSON.stringify(messageData, null, 2);\n            } catch (error) {\n                console.error('Error stringifying message object:', error);\n                return '[Complex object]';\n            }\n        }\n    }\n    // Handle other types (number, boolean, etc.)\n    return String(messageData);\n};\n/**\n * Parse multiple choice options from a message text\n * @param {string} messageText - The message text to parse\n * @returns {string[]} - Array of option strings\n */ const parseOptions = (messageText)=>{\n    const formattedText = formatMessage(messageText);\n    const options = [];\n    if (!formattedText) {\n        return options;\n    }\n    const lines = formattedText.split('\\n');\n    // Extract options (A., B., C., D. format)\n    for (const line of lines){\n        if (line.match(/^[A-D]\\.\\s/)) {\n            options.push(line.trim());\n        }\n    }\n    return options;\n};\n/**\n * Checks if a response contains a valid message\n * @param {object} response - The API response object\n * @returns {boolean} - Whether the response has a valid message\n */ const hasValidMessage = (response)=>{\n    return response && (response.message !== undefined || typeof response === 'string' || typeof response === 'object' && !response.competency_status);\n};\n/**\n * Extracts the message content from a response\n * @param {object} response - The API response object\n * @returns {string} - The extracted message content\n */ const extractMessageFromResponse = (response)=>{\n    if (!response) {\n        return '';\n    }\n    if (response.message !== undefined) {\n        return response.message;\n    } else if (typeof response === 'string') {\n        return response;\n    } else if (typeof response === 'object' && !response.competency_status) {\n        return response;\n    }\n    return '';\n};\n/**\n * Checks if a text contains an image URL\n * @param {string} text - Text to check for image URLs\n * @returns {boolean} - Whether the text contains an image URL\n */ const containsImageUrl = (text)=>{\n    if (!text || typeof text !== 'string') return false;\n    // Check for common image extensions\n    const imageExtensionRegex = /https?:\\/\\/\\S+\\.(jpg|jpeg|png|gif|bmp|webp|svg)(\\?.*)?(\\s|$)/i;\n    // Check for Google Drive image links specifically - note the updated pattern\n    const driveImageRegex = /https?:\\/\\/drive\\.(?:google\\.)?usercontent\\.google\\.com\\/(?:download|view)\\S*/i;\n    // Check for content IDs in Google Drive links\n    const driveContentRegex = /id=[\\w-]+/i;\n    return imageExtensionRegex.test(text) || driveImageRegex.test(text) && driveContentRegex.test(text);\n};\n/**\n * Extracts image URL from text\n * @param {string} text - Text containing an image URL\n * @returns {string|null} - The extracted image URL or null if not found\n */ const extractImageUrl = (text)=>{\n    if (!text || typeof text !== 'string') return null;\n    // Try to match standard image URLs first\n    const imageMatch = text.match(/https?:\\/\\/\\S+\\.(jpg|jpeg|png|gif|bmp|webp|svg)(\\?[^\"'\\s]*)?/i);\n    if (imageMatch) return imageMatch[0];\n    // Try to match Google Drive image URLs with improved pattern\n    const driveMatch = text.match(/https?:\\/\\/drive\\.(?:google\\.)?usercontent\\.google\\.com\\/(?:download|view)\\S+?(?=[\\s\"']|$)/i);\n    if (driveMatch) {\n        // Return the full matched URL\n        return driveMatch[0];\n    }\n    return null;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL21lc3NhZ2VVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx3QkFBd0I7QUFDeEI7O0NBRUMsR0FFRDs7OztDQUlDLEdBQ00sTUFBTUEsZ0JBQWdCLENBQUNDO0lBQzVCLDZCQUE2QjtJQUM3QixJQUFJQSxnQkFBZ0JDLGFBQWFELGdCQUFnQixNQUFNO1FBQ3JELE9BQU87SUFDVDtJQUVBLHFCQUFxQjtJQUNyQixJQUFJLE9BQU9BLGdCQUFnQixVQUFVO1FBQ25DLE9BQU9BO0lBQ1Q7SUFFQSxxQkFBcUI7SUFDckIsSUFBSSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUNuQyxvREFBb0Q7UUFDcEQsSUFBSUEsWUFBWUUsSUFBSSxFQUFFO1lBQ3BCLE9BQU9GLFlBQVlFLElBQUk7UUFDekIsT0FBTyxJQUFJRixZQUFZRyxPQUFPLEVBQUU7WUFDOUIsT0FBT0gsWUFBWUcsT0FBTztRQUM1QixPQUFPLElBQUlILFlBQVlJLE9BQU8sRUFBRTtZQUM5QixPQUFPSixZQUFZSSxPQUFPO1FBQzVCLE9BQU87WUFDTCxJQUFJO2dCQUNGLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ04sYUFBYSxNQUFNO1lBQzNDLEVBQUUsT0FBT08sT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLHNDQUFzQ0E7Z0JBQ3BELE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFFQSw2Q0FBNkM7SUFDN0MsT0FBT0UsT0FBT1Q7QUFDaEIsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNVSxlQUFlLENBQUNDO0lBQzNCLE1BQU1DLGdCQUFnQmIsY0FBY1k7SUFDcEMsTUFBTUUsVUFBVSxFQUFFO0lBRWxCLElBQUksQ0FBQ0QsZUFBZTtRQUNsQixPQUFPQztJQUNUO0lBRUEsTUFBTUMsUUFBUUYsY0FBY0csS0FBSyxDQUFDO0lBRWxDLDBDQUEwQztJQUMxQyxLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSUUsS0FBS0MsS0FBSyxDQUFDLGVBQWU7WUFDNUJKLFFBQVFLLElBQUksQ0FBQ0YsS0FBS0csSUFBSTtRQUN4QjtJQUNGO0lBRUEsT0FBT047QUFDVCxFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU1PLGtCQUFrQixDQUFDQztJQUM5QixPQUFPQSxZQUNMQSxDQUFBQSxTQUFTakIsT0FBTyxLQUFLSCxhQUNyQixPQUFPb0IsYUFBYSxZQUNuQixPQUFPQSxhQUFhLFlBQVksQ0FBQ0EsU0FBU0MsaUJBQWlCO0FBRWhFLEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTUMsNkJBQTZCLENBQUNGO0lBQ3pDLElBQUksQ0FBQ0EsVUFBVTtRQUNiLE9BQU87SUFDVDtJQUVBLElBQUlBLFNBQVNqQixPQUFPLEtBQUtILFdBQVc7UUFDbEMsT0FBT29CLFNBQVNqQixPQUFPO0lBQ3pCLE9BQU8sSUFBSSxPQUFPaUIsYUFBYSxVQUFVO1FBQ3ZDLE9BQU9BO0lBQ1QsT0FBTyxJQUFJLE9BQU9BLGFBQWEsWUFBWSxDQUFDQSxTQUFTQyxpQkFBaUIsRUFBRTtRQUN0RSxPQUFPRDtJQUNUO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTUcsbUJBQW1CLENBQUN0QjtJQUMvQixJQUFJLENBQUNBLFFBQVEsT0FBT0EsU0FBUyxVQUFVLE9BQU87SUFFOUMsb0NBQW9DO0lBQ3BDLE1BQU11QixzQkFBc0I7SUFFNUIsNkVBQTZFO0lBQzdFLE1BQU1DLGtCQUFrQjtJQUV4Qiw4Q0FBOEM7SUFDOUMsTUFBTUMsb0JBQW9CO0lBRTFCLE9BQVFGLG9CQUFvQkcsSUFBSSxDQUFDMUIsU0FDekJ3QixnQkFBZ0JFLElBQUksQ0FBQzFCLFNBQVN5QixrQkFBa0JDLElBQUksQ0FBQzFCO0FBQy9ELEVBQUU7QUFFRjs7OztDQUlDLEdBQ00sTUFBTTJCLGtCQUFrQixDQUFDM0I7SUFDOUIsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsVUFBVSxPQUFPO0lBRTlDLHlDQUF5QztJQUN6QyxNQUFNNEIsYUFBYTVCLEtBQUtlLEtBQUssQ0FBQztJQUM5QixJQUFJYSxZQUFZLE9BQU9BLFVBQVUsQ0FBQyxFQUFFO0lBRXBDLDZEQUE2RDtJQUM3RCxNQUFNQyxhQUFhN0IsS0FBS2UsS0FBSyxDQUFDO0lBQzlCLElBQUljLFlBQVk7UUFDZCw4QkFBOEI7UUFDOUIsT0FBT0EsVUFBVSxDQUFDLEVBQUU7SUFDdEI7SUFFQSxPQUFPO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2JhbHFpc25hZ3V3aWIvTGlicmFyeS9DbG91ZFN0b3JhZ2UvT25lRHJpdmUtVGVsZWtvbU1hbGF5c2lhQmVyaGFkL0RvY3VtZW50cy9BSS9BSS1EYXkvdG0tYWktd2lkZ2V0L3V0aWxzL21lc3NhZ2VVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1dGlscy9tZXNzYWdlVXRpbHMuanNcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIG1lc3NhZ2UgaGFuZGxpbmcgYW5kIGZvcm1hdHRpbmdcbiAqL1xuXG4vKipcbiAqIEZvcm1hdHMgbWVzc2FnZSBkYXRhIHRvIGVuc3VyZSBpdCdzIGluIGEgY29uc2lzdGVudCBzdHJpbmcgZm9ybWF0XG4gKiBAcGFyYW0ge2FueX0gbWVzc2FnZURhdGEgLSBUaGUgbWVzc2FnZSBkYXRhIHRvIGZvcm1hdCAoY291bGQgYmUgc3RyaW5nLCBvYmplY3QsIG51bGwsIGV0Yy4pXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBmb3JtYXR0ZWQgbWVzc2FnZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdE1lc3NhZ2UgPSAobWVzc2FnZURhdGEpID0+IHtcbiAgLy8gSGFuZGxlIHVuZGVmaW5lZC9udWxsIGNhc2VcbiAgaWYgKG1lc3NhZ2VEYXRhID09PSB1bmRlZmluZWQgfHwgbWVzc2FnZURhdGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgXG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZVxuICBpZiAodHlwZW9mIG1lc3NhZ2VEYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXNzYWdlRGF0YTtcbiAgfVxuICBcbiAgLy8gSGFuZGxlIG9iamVjdCBjYXNlXG4gIGlmICh0eXBlb2YgbWVzc2FnZURhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgdGV4dCBmcm9tIGNvbW1vbiBvYmplY3Qgc3RydWN0dXJlc1xuICAgIGlmIChtZXNzYWdlRGF0YS50ZXh0KSB7XG4gICAgICByZXR1cm4gbWVzc2FnZURhdGEudGV4dDtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2VEYXRhLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlRGF0YS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZURhdGEubWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VEYXRhLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZXNzYWdlRGF0YSwgbnVsbCwgMik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdHJpbmdpZnlpbmcgbWVzc2FnZSBvYmplY3Q6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gJ1tDb21wbGV4IG9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gSGFuZGxlIG90aGVyIHR5cGVzIChudW1iZXIsIGJvb2xlYW4sIGV0Yy4pXG4gIHJldHVybiBTdHJpbmcobWVzc2FnZURhdGEpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBtdWx0aXBsZSBjaG9pY2Ugb3B0aW9ucyBmcm9tIGEgbWVzc2FnZSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVRleHQgLSBUaGUgbWVzc2FnZSB0ZXh0IHRvIHBhcnNlXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQXJyYXkgb2Ygb3B0aW9uIHN0cmluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlT3B0aW9ucyA9IChtZXNzYWdlVGV4dCkgPT4ge1xuICBjb25zdCBmb3JtYXR0ZWRUZXh0ID0gZm9ybWF0TWVzc2FnZShtZXNzYWdlVGV4dCk7XG4gIGNvbnN0IG9wdGlvbnMgPSBbXTtcbiAgXG4gIGlmICghZm9ybWF0dGVkVGV4dCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIFxuICBjb25zdCBsaW5lcyA9IGZvcm1hdHRlZFRleHQuc3BsaXQoJ1xcbicpO1xuICBcbiAgLy8gRXh0cmFjdCBvcHRpb25zIChBLiwgQi4sIEMuLCBELiBmb3JtYXQpXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGlmIChsaW5lLm1hdGNoKC9eW0EtRF1cXC5cXHMvKSkge1xuICAgICAgb3B0aW9ucy5wdXNoKGxpbmUudHJpbSgpKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSByZXNwb25zZSBjb250YWlucyBhIHZhbGlkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAtIFRoZSBBUEkgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRoZSByZXNwb25zZSBoYXMgYSB2YWxpZCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNWYWxpZE1lc3NhZ2UgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIHJlc3BvbnNlICYmIChcbiAgICByZXNwb25zZS5tZXNzYWdlICE9PSB1bmRlZmluZWQgfHwgXG4gICAgdHlwZW9mIHJlc3BvbnNlID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcmVzcG9uc2UgPT09ICdvYmplY3QnICYmICFyZXNwb25zZS5jb21wZXRlbmN5X3N0YXR1cylcbiAgKTtcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIG1lc3NhZ2UgY29udGVudCBmcm9tIGEgcmVzcG9uc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAtIFRoZSBBUEkgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBleHRyYWN0ZWQgbWVzc2FnZSBjb250ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBleHRyYWN0TWVzc2FnZUZyb21SZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIFxuICBpZiAocmVzcG9uc2UubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLm1lc3NhZ2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICdvYmplY3QnICYmICFyZXNwb25zZS5jb21wZXRlbmN5X3N0YXR1cykge1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBcbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSB0ZXh0IGNvbnRhaW5zIGFuIGltYWdlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IHRvIGNoZWNrIGZvciBpbWFnZSBVUkxzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRoZSB0ZXh0IGNvbnRhaW5zIGFuIGltYWdlIFVSTFxuICovXG5leHBvcnQgY29uc3QgY29udGFpbnNJbWFnZVVybCA9ICh0ZXh0KSA9PiB7XG4gIGlmICghdGV4dCB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIENoZWNrIGZvciBjb21tb24gaW1hZ2UgZXh0ZW5zaW9uc1xuICBjb25zdCBpbWFnZUV4dGVuc2lvblJlZ2V4ID0gL2h0dHBzPzpcXC9cXC9cXFMrXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8Ym1wfHdlYnB8c3ZnKShcXD8uKik/KFxcc3wkKS9pO1xuICBcbiAgLy8gQ2hlY2sgZm9yIEdvb2dsZSBEcml2ZSBpbWFnZSBsaW5rcyBzcGVjaWZpY2FsbHkgLSBub3RlIHRoZSB1cGRhdGVkIHBhdHRlcm5cbiAgY29uc3QgZHJpdmVJbWFnZVJlZ2V4ID0gL2h0dHBzPzpcXC9cXC9kcml2ZVxcLig/Omdvb2dsZVxcLik/dXNlcmNvbnRlbnRcXC5nb29nbGVcXC5jb21cXC8oPzpkb3dubG9hZHx2aWV3KVxcUyovaTtcbiAgXG4gIC8vIENoZWNrIGZvciBjb250ZW50IElEcyBpbiBHb29nbGUgRHJpdmUgbGlua3NcbiAgY29uc3QgZHJpdmVDb250ZW50UmVnZXggPSAvaWQ9W1xcdy1dKy9pO1xuICBcbiAgcmV0dXJuIChpbWFnZUV4dGVuc2lvblJlZ2V4LnRlc3QodGV4dCkgfHwgXG4gICAgICAgICAoZHJpdmVJbWFnZVJlZ2V4LnRlc3QodGV4dCkgJiYgZHJpdmVDb250ZW50UmVnZXgudGVzdCh0ZXh0KSkpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBpbWFnZSBVUkwgZnJvbSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgY29udGFpbmluZyBhbiBpbWFnZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gLSBUaGUgZXh0cmFjdGVkIGltYWdlIFVSTCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdEltYWdlVXJsID0gKHRleHQpID0+IHtcbiAgaWYgKCF0ZXh0IHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGw7XG4gIFxuICAvLyBUcnkgdG8gbWF0Y2ggc3RhbmRhcmQgaW1hZ2UgVVJMcyBmaXJzdFxuICBjb25zdCBpbWFnZU1hdGNoID0gdGV4dC5tYXRjaCgvaHR0cHM/OlxcL1xcL1xcUytcXC4oanBnfGpwZWd8cG5nfGdpZnxibXB8d2VicHxzdmcpKFxcP1teXCInXFxzXSopPy9pKTtcbiAgaWYgKGltYWdlTWF0Y2gpIHJldHVybiBpbWFnZU1hdGNoWzBdO1xuICBcbiAgLy8gVHJ5IHRvIG1hdGNoIEdvb2dsZSBEcml2ZSBpbWFnZSBVUkxzIHdpdGggaW1wcm92ZWQgcGF0dGVyblxuICBjb25zdCBkcml2ZU1hdGNoID0gdGV4dC5tYXRjaCgvaHR0cHM/OlxcL1xcL2RyaXZlXFwuKD86Z29vZ2xlXFwuKT91c2VyY29udGVudFxcLmdvb2dsZVxcLmNvbVxcLyg/OmRvd25sb2FkfHZpZXcpXFxTKz8oPz1bXFxzXCInXXwkKS9pKTtcbiAgaWYgKGRyaXZlTWF0Y2gpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGZ1bGwgbWF0Y2hlZCBVUkxcbiAgICByZXR1cm4gZHJpdmVNYXRjaFswXTtcbiAgfVxuICBcbiAgcmV0dXJuIG51bGw7XG59O1xuIl0sIm5hbWVzIjpbImZvcm1hdE1lc3NhZ2UiLCJtZXNzYWdlRGF0YSIsInVuZGVmaW5lZCIsInRleHQiLCJjb250ZW50IiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJTdHJpbmciLCJwYXJzZU9wdGlvbnMiLCJtZXNzYWdlVGV4dCIsImZvcm1hdHRlZFRleHQiLCJvcHRpb25zIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJtYXRjaCIsInB1c2giLCJ0cmltIiwiaGFzVmFsaWRNZXNzYWdlIiwicmVzcG9uc2UiLCJjb21wZXRlbmN5X3N0YXR1cyIsImV4dHJhY3RNZXNzYWdlRnJvbVJlc3BvbnNlIiwiY29udGFpbnNJbWFnZVVybCIsImltYWdlRXh0ZW5zaW9uUmVnZXgiLCJkcml2ZUltYWdlUmVnZXgiLCJkcml2ZUNvbnRlbnRSZWdleCIsInRlc3QiLCJleHRyYWN0SW1hZ2VVcmwiLCJpbWFnZU1hdGNoIiwiZHJpdmVNYXRjaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/messageUtils.js\n"));

/***/ })

});